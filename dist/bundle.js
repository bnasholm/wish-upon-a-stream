/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/constants/index.ts":
/*!********************************!*\
  !*** ./src/constants/index.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ASPECT_RATIO: () => (/* binding */ ASPECT_RATIO),\n/* harmony export */   CAROUSEL_IMG_1: () => (/* binding */ CAROUSEL_IMG_1),\n/* harmony export */   CAROUSEL_IMG_2: () => (/* binding */ CAROUSEL_IMG_2),\n/* harmony export */   CAROUSEL_IMG_3: () => (/* binding */ CAROUSEL_IMG_3),\n/* harmony export */   DISNEY_PLUS_LOGO: () => (/* binding */ DISNEY_PLUS_LOGO),\n/* harmony export */   FALL_BACK_IMG: () => (/* binding */ FALL_BACK_IMG)\n/* harmony export */ });\nconst ASPECT_RATIO = 1.78;\nconst DISNEY_PLUS_LOGO = \"./assets/disneyplus-white.webp\";\nconst FALL_BACK_IMG = \"./assets/fallback.webp\";\nconst CAROUSEL_IMG_1 = \"./assets/carouselImage1.jpeg\";\nconst CAROUSEL_IMG_2 = \"./assets/carouselImage2.jpeg\";\nconst CAROUSEL_IMG_3 = \"./assets/carouselImage3.jpeg\";\n\n\n//# sourceURL=webpack://wishuponastream/./src/constants/index.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ts */ \"./src/ts/index.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"./src/constants/index.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n/* ------------------ FETCH DATA ----------------------------*/\n/* renders loading screen while fetching homppage data, then adds\n * the fetched data to elements on the DOM\n * lastly, initializes the Intersection Observer to watch for when\n * elements are scrolled into view to lazily load those dynamic sets\n */\nconst fetchAndRenderHomePageData = () => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        renderLoadingScreen();\n        const data = yield (0,_ts__WEBPACK_IMPORTED_MODULE_0__.fetchHomePageData)();\n        if (data) {\n            const containers = data.StandardCollection.containers;\n            const appContainer = document.querySelector(\"#app\");\n            const mainContent = document.createElement(\"div\");\n            mainContent.id = \"main-content\";\n            appContainer === null || appContainer === void 0 ? void 0 : appContainer.appendChild(mainContent);\n            const modalContainer = document.createElement(\"div\");\n            modalContainer.className = \"modal-container\";\n            const newModalContent = document.createElement(\"div\");\n            newModalContent.className = \"modal\";\n            modalContainer.appendChild(newModalContent);\n            appContainer === null || appContainer === void 0 ? void 0 : appContainer.appendChild(modalContainer);\n            renderDefaultContent(containers);\n        }\n        const firstTile = document.querySelector(\".tile-wrapper\");\n        firstTile.focus();\n        window.moveTo(0, 0);\n        initializeObserver();\n    }\n    catch (e) {\n        console.error(\"Error fetching home page data:\", e);\n        renderErrorScreen();\n    }\n});\n/* renders the dynamic ref content by making additional\n * call to fetch by refId\n */\nconst fetchAndRenderDynamicData = (refId) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a, _b, _c;\n    const data = yield (0,_ts__WEBPACK_IMPORTED_MODULE_0__.fetchRefData)(refId);\n    if (data) {\n        const set = (_c = (_b = (_a = data.CuratedSet) !== null && _a !== void 0 ? _a : data.TrendingSet) !== null && _b !== void 0 ? _b : data.PersonalizedCuratedSet) !== null && _c !== void 0 ? _c : undefined;\n        if (!!set)\n            renderDynamicContent(refId, set);\n    }\n});\n/* sets up Observer so we can dynamically load the ref sections when scrolled into view */\nconst initializeObserver = () => {\n    const allSections = document.querySelectorAll(\"section\");\n    const observer = new IntersectionObserver((entries, observer) => {\n        entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n                const target = entry.target;\n                const refId = target.dataset.refId;\n                if (refId)\n                    fetchAndRenderDynamicData(refId);\n                observer.unobserve(target);\n            }\n        });\n    }, \n    // when 50% of element is visible\n    { threshold: 0.5 });\n    allSections.forEach((section) => observer.observe(section));\n};\n/* ------------------ RENDER CONTENT ------------------------*/\n/* render nav bar which contains logo and a user */\nconst renderNavBar = () => {\n    const appContainer = document.getElementById(\"app\");\n    const navBar = document.createElement(\"div\");\n    navBar.id = \"nav-bar\";\n    const logo = document.createElement(\"img\");\n    logo.id = \"disney-logo-small\";\n    logo.src = _constants__WEBPACK_IMPORTED_MODULE_1__.DISNEY_PLUS_LOGO;\n    const profileIcon = document.createElement(\"div\");\n    profileIcon.className = \"profile-icon\";\n    const initials = document.createElement(\"p\");\n    initials.textContent = \"BN\";\n    profileIcon.appendChild(initials);\n    navBar.appendChild(logo);\n    navBar.appendChild(profileIcon);\n    appContainer === null || appContainer === void 0 ? void 0 : appContainer.appendChild(navBar);\n};\n/* render  carousel that rotates between 3 images to\n * advertise what is new on app\n */\nconst renderCarouselContent = () => {\n    const appContainer = document.getElementById(\"app\");\n    const carouselElement = document.createElement(\"div\");\n    carouselElement.innerHTML = `<div class=\"carousel-container\">\n        <div class=\"carousel-track\">\n            <div class=\"carousel-slide\">\n              <img src=${_constants__WEBPACK_IMPORTED_MODULE_1__.CAROUSEL_IMG_1} alt=\"Image 1\" />\n              <img src=${_constants__WEBPACK_IMPORTED_MODULE_1__.CAROUSEL_IMG_2} alt=\"Image 2\" />\n              <img src=${_constants__WEBPACK_IMPORTED_MODULE_1__.CAROUSEL_IMG_3} alt=\"Image 3\" />\n            </div>\n        </div>\n    </div>`;\n    appContainer === null || appContainer === void 0 ? void 0 : appContainer.appendChild(carouselElement);\n    (0,_ts__WEBPACK_IMPORTED_MODULE_0__.handleCarouselAnimation)();\n};\n/* renders loading screen that displays for set period of time while data is loading\n *  Disney logo fades in and out\n */\nconst renderLoadingScreen = () => {\n    const appContainer = document.getElementById(\"app\");\n    const loadingScreen = document.createElement(\"div\");\n    loadingScreen.id = \"loading-screen\";\n    const logo = document.createElement(\"img\");\n    logo.id = \"disney-logo\";\n    logo.src = _constants__WEBPACK_IMPORTED_MODULE_1__.DISNEY_PLUS_LOGO;\n    loadingScreen.appendChild(logo);\n    appContainer === null || appContainer === void 0 ? void 0 : appContainer.appendChild(loadingScreen);\n};\n/* renders error screen if an error is caught\n * includes button to refresh page on Enter key\n */\nconst renderErrorScreen = () => {\n    const appContainer = document.getElementById(\"app\");\n    const errorScreen = document.createElement(\"div\");\n    errorScreen.id = \"error-screen\";\n    const errorMessage = document.createElement(\"div\");\n    errorMessage.id = \"error-message\";\n    const oopsHeading = document.createElement(\"h1\");\n    oopsHeading.textContent = \"Oops, something went wrong.\";\n    const additionalText = document.createElement(\"p\");\n    additionalText.textContent =\n        \"Please try again. If the problem persists, visit our help center at help.disneyplus.com.\";\n    const button = document.createElement(\"button\");\n    const buttonText = document.createElement(\"p\");\n    buttonText.textContent = \"Retry\";\n    button.appendChild(buttonText);\n    errorMessage.appendChild(oopsHeading);\n    errorMessage.appendChild(additionalText);\n    errorMessage.appendChild(button);\n    errorScreen.appendChild(errorMessage);\n    appContainer === null || appContainer === void 0 ? void 0 : appContainer.appendChild(errorScreen);\n};\n/* renders individual thumbnail tile image and if applicable, video\n * video plays on tile focus and stops when unfocused\n * image opacity is hidden when video is playing and vice versa\n * element is an anchor tag that opens modal on Enter\n */\nconst renderTile = (tile) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const tileInfo = tile.image.tile[_constants__WEBPACK_IMPORTED_MODULE_1__.ASPECT_RATIO];\n    const urlWrapper = (_f = (_d = (_b = (_a = tileInfo.series) === null || _a === void 0 ? void 0 : _a.default) !== null && _b !== void 0 ? _b : (_c = tileInfo.program) === null || _c === void 0 ? void 0 : _c.default) !== null && _d !== void 0 ? _d : (_e = tileInfo.default) === null || _e === void 0 ? void 0 : _e.default) !== null && _f !== void 0 ? _f : undefined;\n    if (urlWrapper) {\n        const newTileWrapper = document.createElement(\"a\");\n        const title = (_w = (_r = (_l = (_k = (_j = (_h = (_g = tile === null || tile === void 0 ? void 0 : tile.text) === null || _g === void 0 ? void 0 : _g.title) === null || _h === void 0 ? void 0 : _h.full) === null || _j === void 0 ? void 0 : _j.series) === null || _k === void 0 ? void 0 : _k.default) !== null && _l !== void 0 ? _l : (_q = (_p = (_o = (_m = tile === null || tile === void 0 ? void 0 : tile.text) === null || _m === void 0 ? void 0 : _m.title) === null || _o === void 0 ? void 0 : _o.full) === null || _p === void 0 ? void 0 : _p.program) === null || _q === void 0 ? void 0 : _q.default) !== null && _r !== void 0 ? _r : (_v = (_u = (_t = (_s = tile === null || tile === void 0 ? void 0 : tile.text) === null || _s === void 0 ? void 0 : _s.title) === null || _t === void 0 ? void 0 : _t.full) === null || _u === void 0 ? void 0 : _u.default) === null || _v === void 0 ? void 0 : _v.default) !== null && _w !== void 0 ? _w : undefined;\n        newTileWrapper.id = tile.contentId || tile.collectionId || \"\";\n        if (title === null || title === void 0 ? void 0 : title.content)\n            newTileWrapper.dataset.title = title.content;\n        newTileWrapper.tabIndex = 0;\n        newTileWrapper.className = \"tile-wrapper\";\n        const newTileImage = document.createElement(\"img\");\n        const hasValidImage = !!urlWrapper.url && (0,_ts__WEBPACK_IMPORTED_MODULE_0__.isValidURL)(urlWrapper.url);\n        newTileImage.src = hasValidImage ? urlWrapper.url : \"\";\n        newTileImage.className = \"media-img\";\n        const newSourceElement = document.createElement(\"source\");\n        const videoSrc = tile.videoArt &&\n            tile.videoArt.length > 0 &&\n            ((_x = tile.videoArt[0].mediaMetadata) === null || _x === void 0 ? void 0 : _x.urls) &&\n            ((_y = tile.videoArt[0].mediaMetadata) === null || _y === void 0 ? void 0 : _y.urls.length) > 0\n            ? (_0 = (_z = tile.videoArt[0]) === null || _z === void 0 ? void 0 : _z.mediaMetadata) === null || _0 === void 0 ? void 0 : _0.urls[0].url\n            : undefined;\n        const hasVideo = !!videoSrc;\n        newSourceElement.src = !!videoSrc ? videoSrc : \"\";\n        newSourceElement.type = \"video/mp4\";\n        const newVideoElement = document.createElement(\"video\");\n        newVideoElement.className = \"media-video\";\n        newVideoElement.appendChild(newSourceElement);\n        newVideoElement.muted = true;\n        newVideoElement.loop = true;\n        // allows proper positioning for video to play over top\n        if (hasVideo)\n            newTileImage.classList.add(\"has-video\");\n        // only append child tile on successful load of thumbnail\n        newTileImage.onload = () => {\n            newTileWrapper.appendChild(newTileImage);\n            if (hasVideo)\n                newTileWrapper.appendChild(newVideoElement);\n        };\n        // if image fails to load display fall back image and append title over top\n        newTileImage.onerror = (e) => {\n            console.warn(\"Error fetching image thumbnail\", e);\n            newTileImage.src = _constants__WEBPACK_IMPORTED_MODULE_1__.FALL_BACK_IMG;\n            const titleElement = document.createElement(\"p\");\n            titleElement.className = \"fallback-img-title\";\n            if (title && (title === null || title === void 0 ? void 0 : title.content))\n                titleElement.textContent = title.content;\n            newTileWrapper.appendChild(titleElement);\n        };\n        if (hasVideo) {\n            newTileWrapper.onfocus = () => {\n                // hide thumbnail, show video\n                const titleElement = newTileWrapper.querySelector(\".fallback-img-title\");\n                if (titleElement)\n                    titleElement.style.opacity = \"0\";\n                newTileImage.style.opacity = \"0\";\n                newVideoElement.style.opacity = \"1\";\n                newVideoElement.play().catch((e) => {\n                    console.warn(\"Error playing video\", e);\n                });\n            };\n            newVideoElement.onerror = (e) => console.warn(\"Error fetching video\", e);\n            newTileWrapper.onblur = () => __awaiter(void 0, void 0, void 0, function* () {\n                newVideoElement.pause();\n                newVideoElement.currentTime = 0;\n                // hide video, show thumbnail img\n                const titleElement = newTileWrapper.querySelector(\".fallback-img-title\");\n                if (titleElement)\n                    titleElement.style.opacity = \"1\";\n                newTileImage.style.opacity = \"1\";\n                newVideoElement.style.opacity = \"0\";\n            });\n        }\n        return newTileWrapper;\n    }\n};\n/* takes in row items and renders the row\n * a row is a section of content such as \"New to Disney+\"\n * each row consists of thumbnail tiles\n */\nconst renderSection = (section) => {\n    const newSection = document.createElement(\"section\");\n    newSection.id =\n        (section.set.type === \"ShelfContainer\" || section.set.type === \"CuratedSet\"\n            ? section.set.setId\n            : section.set.refId) || \"\";\n    const newHeading = document.createElement(\"h2\");\n    newHeading.className = \"heading\";\n    newHeading.textContent = section.set.text.title.full.set.default.content;\n    newSection.appendChild(newHeading);\n    const tileSection = document.createElement(\"div\");\n    tileSection.className = \"tile-section\";\n    const fragment = document.createDocumentFragment();\n    if (section.set.items) {\n        section.set.items.forEach((item) => {\n            try {\n                const tileWrapper = renderTile(item);\n                if (tileWrapper)\n                    fragment.appendChild(tileWrapper);\n            }\n            catch (e) {\n                console.error(\"Error rendering tile:\", e);\n            }\n        });\n    }\n    tileSection.appendChild(fragment);\n    if (section.set.refId) {\n        newSection.dataset.refId = section.set.refId;\n    }\n    newSection.appendChild(tileSection);\n    return newSection;\n};\n/* renders the content inside of modal\n * when thumbnail is selected, modal opens and shows\n * larger size video and info about the selection\n */\nconst renderModalContent = (element) => {\n    var _a;\n    const modal = document.querySelector(\".modal\");\n    const newDiv = document.createElement(\"div\");\n    const headingElement = document.createElement(\"h1\");\n    const descriptionElement = document.createElement(\"p\");\n    descriptionElement.textContent =\n        \"Lorem ipsum odor amet, consectetuer adipiscing elit. Dapibus bibendum hendrerit sem semper lorem sollicitudin viverra pretium. Ridiculus elementum potenti lacus hac cursus fringilla morbi nibh.\";\n    const videoContainerElement = document.createElement(\"div\");\n    videoContainerElement.id = \"modal-video-container\";\n    const newSourceElement = document.createElement(\"source\");\n    const title = element.dataset.title;\n    const videoSrc = ((_a = element.querySelector(\".media-video > source\")) === null || _a === void 0 ? void 0 : _a.src) || undefined;\n    newSourceElement.src = !!videoSrc ? videoSrc : \"\";\n    newSourceElement.type = \"video/mp4\";\n    const videoElement = document.createElement(\"video\");\n    videoElement.controls = true;\n    videoElement.classList.add(\"media-video\");\n    videoElement.classList.add(\"no-focus\");\n    videoElement.appendChild(newSourceElement);\n    videoElement.muted = false;\n    videoElement.preload = \"auto\";\n    headingElement.textContent = title || \"\";\n    videoContainerElement.appendChild(videoElement);\n    newDiv.id = \"modal-content\";\n    newDiv.dataset.contentId = element.id;\n    newDiv.appendChild(headingElement);\n    if (!!videoSrc)\n        newDiv.appendChild(videoContainerElement);\n    newDiv.appendChild(descriptionElement);\n    modal === null || modal === void 0 ? void 0 : modal.appendChild(newDiv);\n    // if there is no video, focus on the description element instead\n    if (!!videoSrc)\n        videoElement.focus();\n    else\n        descriptionElement.focus();\n};\n/* renders the \"dynamic\" content \"ref\" sets\n * checks if there is an existing section and appends\n * the new data to their appropriate section\n * when this is called, we have already rendered the set\n * section and heading, but content within section isn't\n * fetched until scrolled into view\n */\nconst renderDynamicContent = (refId, data) => {\n    var _a;\n    const existingSection = document.querySelector(`[data-ref-id = '${refId}'] > .tile-section`);\n    (_a = data.items) === null || _a === void 0 ? void 0 : _a.forEach((item) => {\n        const tileWrapper = renderTile(item);\n        if (tileWrapper)\n            existingSection === null || existingSection === void 0 ? void 0 : existingSection.appendChild(tileWrapper);\n    });\n};\n/* loops through hompage data to create sections and\n * add those secitons to the main app container\n */\nconst renderDefaultContent = (data) => {\n    const mainContent = document.querySelector(\"#main-content\");\n    data.forEach((container) => {\n        const newSection = renderSection(container);\n        mainContent === null || mainContent === void 0 ? void 0 : mainContent.appendChild(newSection);\n    });\n};\n/* ------------------ HANDLE EVENTS ------------------------*/\n/* handle navigation between the tiles using keydown events\n *  focus on [left / right / top / bottom] most tile unless it's at\n *  the [start / end / top / bottom] of section\n *  only navigate to next tile if modal is not open\n *  uses getBoundingRect to move to above or below tile in case where\n *  other section has been scrolled\n */\nconst handleKeydownEvents = () => {\n    document.addEventListener(\"keydown\", (event) => {\n        const focusedElement = document.activeElement;\n        const modal = document.querySelector(\".modal-container\");\n        const isModalOpen = modal === null || modal === void 0 ? void 0 : modal.classList.contains(\"modal-open\");\n        const allSections = document.querySelectorAll(\".tile-section\");\n        const currentSection = focusedElement === null || focusedElement === void 0 ? void 0 : focusedElement.closest(\".tile-section\");\n        const currentSectionIndex = currentSection\n            ? Array.from(allSections).indexOf(currentSection)\n            : 0;\n        const currentItemIndex = focusedElement\n            ? Array.from((currentSection === null || currentSection === void 0 ? void 0 : currentSection.childNodes) || []).indexOf(focusedElement)\n            : 0;\n        const prevSection = allSections[currentSectionIndex - 1];\n        const nextSection = allSections[currentSectionIndex + 1];\n        switch (event.key) {\n            // focus on [left / right / top / bottom] most tile unless it's at\n            // the [start / end / top / bottom] of section\n            // only navigate to next tile if modal is not open\n            case \"ArrowLeft\":\n                const prevSibling = focusedElement === null || focusedElement === void 0 ? void 0 : focusedElement.previousElementSibling;\n                if (prevSibling && !isModalOpen) {\n                    prevSibling.focus();\n                    (0,_ts__WEBPACK_IMPORTED_MODULE_0__.checkElementInView)(prevSibling);\n                }\n                break;\n            case \"ArrowRight\":\n                const nextSibling = focusedElement === null || focusedElement === void 0 ? void 0 : focusedElement.nextElementSibling;\n                if (nextSibling && !isModalOpen) {\n                    (0,_ts__WEBPACK_IMPORTED_MODULE_0__.checkElementInView)(nextSibling);\n                    nextSibling.focus();\n                }\n                break;\n            case \"ArrowDown\":\n                if (currentSectionIndex < allSections.length - 1 && !isModalOpen)\n                    handleUpDownNavigation(focusedElement, nextSection);\n                break;\n            case \"ArrowUp\":\n                if (currentSectionIndex > 0 && !isModalOpen)\n                    handleUpDownNavigation(focusedElement, prevSection);\n                break;\n            case \"Enter\":\n                if (!isModalOpen)\n                    handleModalOpen(focusedElement);\n                break;\n            case \"Backspace\":\n                handleModalClose();\n                break;\n            default:\n                break;\n        }\n    });\n};\n/* handles up/ down navigation using getBoundingRect if above section has been scrolled\n * passes in section above or below, checks the horizontal distance of every a element\n * in that section and finds the closest one and focuses it\n * */\nconst handleUpDownNavigation = (focusedElement, prevSection) => {\n    const focusableElements = Array.from(prevSection.querySelectorAll(\".tile-wrapper\"));\n    let closestElement = null;\n    let minDistance = Infinity;\n    const currentRect = focusedElement.getBoundingClientRect();\n    let currentCenterX = currentRect.left + currentRect.width / 2;\n    focusableElements.forEach((element) => {\n        const rect = element.getBoundingClientRect();\n        const elementCenterX = rect.left + rect.width / 2;\n        let horizontalDistance = Math.abs(currentCenterX - elementCenterX);\n        if (horizontalDistance < minDistance) {\n            minDistance = horizontalDistance;\n            closestElement = element;\n        }\n    });\n    if (closestElement) {\n        closestElement.focus();\n    }\n};\n/* handles opening modal, if video is playing, stop play and reset\n * timer,display modal and content inside modal and add backdrop to\n * main app container\n */\nconst handleModalOpen = (focusedElement) => {\n    const mainContent = document.getElementById(\"main-content\");\n    const modal = document.querySelector(\".modal-container\");\n    const textTitle = document.querySelector(\".fallback-img-title\");\n    // if video is playing, stop\n    const videoElement = focusedElement === null || focusedElement === void 0 ? void 0 : focusedElement.querySelector(\".media-video\");\n    const imageElement = focusedElement === null || focusedElement === void 0 ? void 0 : focusedElement.querySelector(\".media-img\");\n    if (videoElement) {\n        videoElement.pause();\n        videoElement.currentTime = 0;\n        // hide video, show thumbnail img\n        if (textTitle)\n            textTitle.style.opacity = \"1\";\n        imageElement.style.opacity = \"1\";\n        videoElement.style.opacity = \"0\";\n    }\n    renderModalContent(focusedElement);\n    modal === null || modal === void 0 ? void 0 : modal.classList.add(\"modal-open\");\n    mainContent === null || mainContent === void 0 ? void 0 : mainContent.classList.add(\"modal-backdrop\");\n    (0,_ts__WEBPACK_IMPORTED_MODULE_0__.checkElementInView)(modal);\n};\n/* handles closing modal, removing backdrop and updating\n * modal to be display: none;\n */\nconst handleModalClose = () => {\n    const mainContent = document.getElementById(\"main-content\");\n    const modal = document.querySelector(\".modal\");\n    const modalContainer = document.querySelector(\".modal-container\");\n    const modalContent = document.getElementById(\"modal-content\");\n    const contentId = modalContent === null || modalContent === void 0 ? void 0 : modalContent.dataset.contentId;\n    // focus on the element we previously selected\n    if (contentId) {\n        const thumbnail = document.getElementById(contentId);\n        thumbnail === null || thumbnail === void 0 ? void 0 : thumbnail.focus();\n    }\n    // if there is something in the modal, remove it on close\n    if (modalContent)\n        modal === null || modal === void 0 ? void 0 : modal.removeChild(modalContent);\n    modalContainer === null || modalContainer === void 0 ? void 0 : modalContainer.classList.remove(\"modal-open\");\n    mainContent === null || mainContent === void 0 ? void 0 : mainContent.classList.remove(\"modal-backdrop\");\n};\n/* -------------------- MAIN APP ----------------------------*/\nrenderNavBar();\nrenderCarouselContent();\nfetchAndRenderHomePageData()\n    .then(() => (0,_ts__WEBPACK_IMPORTED_MODULE_0__.delay)(3000).then(() => {\n    // fade loading screen\n    const loadingScreen = document.getElementById(\"loading-screen\");\n    if (loadingScreen)\n        loadingScreen.style.opacity = \"0\";\n}), () => {\n    renderErrorScreen();\n    const loadingScreen = document.getElementById(\"loading-screen\");\n    if (loadingScreen)\n        loadingScreen.style.opacity = \"0\";\n})\n    .finally(() => window.scrollTo(0, 0));\nhandleKeydownEvents();\n\n\n//# sourceURL=webpack://wishuponastream/./src/index.ts?");

/***/ }),

/***/ "./src/ts/api/index.ts":
/*!*****************************!*\
  !*** ./src/ts/api/index.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchHomePageData: () => (/* binding */ fetchHomePageData),\n/* harmony export */   fetchRefData: () => (/* binding */ fetchRefData)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst HOME_PAGE_DATA_API = \"https://cd-static.bamgrid.com/dp-117731241344/home.json\";\nconst DYNAMIC_SET_DATA_API = \"https://cd-static.bamgrid.com/dp-117731241344/sets\";\nconst fetchRefData = (refId) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const response = yield fetch(`${DYNAMIC_SET_DATA_API}/${refId}.json`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        const { data } = yield response.json();\n        return data;\n    }\n    catch (error) {\n        console.error(\"Error fetching data:\", error);\n    }\n});\nconst fetchHomePageData = () => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const response = yield fetch(HOME_PAGE_DATA_API);\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        const { data } = yield response.json();\n        return data;\n    }\n    catch (error) {\n        console.error(\"Error fetching data:\", error);\n    }\n});\n\n\n//# sourceURL=webpack://wishuponastream/./src/ts/api/index.ts?");

/***/ }),

/***/ "./src/ts/index.ts":
/*!*************************!*\
  !*** ./src/ts/index.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkElementInView: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.checkElementInView),\n/* harmony export */   delay: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.delay),\n/* harmony export */   fetchHomePageData: () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.fetchHomePageData),\n/* harmony export */   fetchRefData: () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.fetchRefData),\n/* harmony export */   handleCarouselAnimation: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.handleCarouselAnimation),\n/* harmony export */   isValidURL: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.isValidURL)\n/* harmony export */ });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"./src/ts/api/index.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/ts/utils/index.ts\");\n\n\n\n\n//# sourceURL=webpack://wishuponastream/./src/ts/index.ts?");

/***/ }),

/***/ "./src/ts/utils/index.ts":
/*!*******************************!*\
  !*** ./src/ts/utils/index.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkElementInView: () => (/* binding */ checkElementInView),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   handleCarouselAnimation: () => (/* binding */ handleCarouselAnimation),\n/* harmony export */   isValidURL: () => (/* binding */ isValidURL)\n/* harmony export */ });\n/* delay so we can have a loading screen */\nconst delay = (ms) => {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n};\n/* check if resource url is valid */\nconst isValidURL = (url) => {\n    try {\n        new URL(url);\n        return true;\n    }\n    catch (error) {\n        return false;\n    }\n};\n/* check if focused element is cut off so we can scroll into view if so */\nconst checkElementInView = (element) => {\n    if (!element)\n        return;\n    const rect = element.getBoundingClientRect();\n    const isCutOff = rect.bottom > window.innerHeight || rect.top < 0;\n    if (isCutOff) {\n        element.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n    }\n};\nconst handleCarouselAnimation = () => {\n    var _a;\n    const track = document.querySelector(\".carousel-track\");\n    const slides = (_a = document.querySelector(\".carousel-slide\")) === null || _a === void 0 ? void 0 : _a.children;\n    let index = 0;\n    const totalSlides = (slides === null || slides === void 0 ? void 0 : slides.length) || 0;\n    let slideInterval;\n    const nextSlide = () => {\n        index = (index + 1) % totalSlides;\n        // move slide track over 101% each time\n        if (track)\n            track.style.transform = `translateX(-${index * 101}%)`;\n    };\n    const beginSlideshow = () => {\n        // stopSlideshow();\n        slideInterval = setInterval(nextSlide, 5000);\n    };\n    const stopSlideshow = () => clearInterval(slideInterval);\n    beginSlideshow();\n    // remove slide interval on cleanup\n    window.addEventListener(\"beforeunload\", stopSlideshow);\n};\n\n\n//# sourceURL=webpack://wishuponastream/./src/ts/utils/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;